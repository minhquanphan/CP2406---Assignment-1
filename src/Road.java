import java.util.ArrayList;
import java.util.Random;

public class Road {
    private static final int BUS_MIN_LENGTH_FACTOR = 2;
    private static final int BUS_MAX_LENGTH_FACTOR = 5;
    private static int currentRoadNumber;
    private String name;
    private String id;
    private int speedLimit;
    private int length;
    private int currentVehiclesLength = 0;
    private int[] startLocation;
    private int[] endLocation;
    private ArrayList<Car> carsOnRoad = new ArrayList<>();
    private ArrayList<TrafficLight> lightsOnRoad = new ArrayList<>();
    private ArrayList<Road> connectedRoads = new ArrayList<>();

    public Road(String name, int speedLimit, int length, int[] startLocation) {
        this.id = "road_" + nextRoadNumber(); // road ID has pattern road_### where ### is auto generated and incremental
        this.name = name;
        setSpeedLimit(speedLimit);
        setLength(length);
        setStartLocation(startLocation);
        this.endLocation = deduceHorizontalEndLocation(); //only works for horizontal roads;
    }

    public void createCars(int totalCarNumbers) {
        for (int i = 0; i < totalCarNumbers; i++) {
            Car car = new Car("Bentley " + new Random().nextInt(999));
            this.newCarEnteringRoad(car);
        }
    }

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    // to make sure ID is unique, ID should be generated by the system, not entered by users, so there is only getter for ID
    public String getId() { return id; }

    public int getSpeedLimit() {
        return speedLimit;
    }

    public void setSpeedLimit(int speedLimit) {
        validateSpeedLimit(speedLimit);
        this.speedLimit = speedLimit;
    }

    public int getLength() {
        return length;
    }

    public void setLength(int length) {
        validateLength(length);
        this.length = length;
    }

    public void setStartLocation(int[] startLocation) {
        validateLocation(startLocation);
        this.startLocation = startLocation;
        this.endLocation = deduceHorizontalEndLocation(); //only works for horizontal roads;
    }

    public int[] getStartLocation() {
        return startLocation;
    }

    public void setEndLocation(int[] endLocation) {
        validateLocation(endLocation);
        this.endLocation = endLocation;
    }

    public int[] getEndLocation() {
        return endLocation;
    }

    public String locationToBePrinted(int[] location) {
        return("(" + location[0] + "," + location[1] + ")");
    }

    public void printRoadInfo() {
        System.out.printf("Road %s has name %s, speed limit at %dm/s with %dm length at location:%s to %s with %s vehicles %n",
                this.getId(), this.getName(),
                this.getSpeedLimit(), this.getLength(), this.locationToBePrinted(this.getStartLocation()),
                this.locationToBePrinted(this.getEndLocation()), this.carsOnRoad.size());
    }

    public ArrayList<Car> getCarsOnRoad() {
        return this.carsOnRoad;
    }

    public void setCarsOnRoad(ArrayList<Car> carsOnRoad) {
        for(Car car: carsOnRoad) {
            this.newCarEnteringRoad(car);
        }
    }

    public int getCurrentVehiclesLength() { return currentVehiclesLength; }

    public void newCarEnteringRoad(Car car) {
        validateCarLength(car);
        validateUniqueCar(car);
        this.carsOnRoad.add(car);
        this.currentVehiclesLength += car.getLength();
    }

    public ArrayList<TrafficLight> getLightsOnRoad() {
        return lightsOnRoad;
    }

    public void setLightsOnRoad(ArrayList<TrafficLight> lightsOnRoad) {
        this.lightsOnRoad = lightsOnRoad;
    }

    public ArrayList<Road> getConnectedRoads() {
        return connectedRoads;
    }

    public void setConnectedRoads(ArrayList<Road> connectedRoads) {
        this.connectedRoads = connectedRoads;
    }

    private int nextRoadNumber() {
        currentRoadNumber += 1;
        return currentRoadNumber;
    }

    private void validateLength(int length) {
        if (length < 1) {
            throw new IllegalArgumentException("Length must be positive.");
        }
    }

    private void validateLocation(int[] location) {
        if (location.length != 2 || location[0] < 0 || location[1] < 0) {
            throw new IllegalArgumentException("Location takes only 2 values which must not be negative.");
        }
    }

    private void validateSpeedLimit(int speedLimit) {
        if (speedLimit < 1) {
            throw new IllegalArgumentException("Speed limit must be positive.");
        }
    }

    private void validateCarLength(Car car) {
        if ((car instanceof Bus) && (this.length < BUS_MIN_LENGTH_FACTOR*car.getLength())) {
            throw new IllegalArgumentException("Bus ID " + car.getId() +
                    " cannot enter this road which has length less than " + BUS_MIN_LENGTH_FACTOR + " times the length of it.");
        }

        if ((car instanceof Bus) && (this.length > BUS_MAX_LENGTH_FACTOR*car.getLength())) {
            throw new IllegalArgumentException("Bus ID" + car.getId() +
                    "cannot enter this road which has length more than " + BUS_MAX_LENGTH_FACTOR + " times the length of it.");
        }

        if ((currentVehiclesLength + car.getLength()) > this.length) {
            throw new IllegalArgumentException("This road has full vehicles driving on. Please wait to be able to enter the road.");
        }
    }

    private void validateUniqueCar(Car car) {
        for (Car currentCar: this.carsOnRoad) {
            if (currentCar.getId().equals(car.getId())){
                throw new IllegalArgumentException("This car has already been added to the road");
            }
        }
    }

    private int[] deduceHorizontalEndLocation() {
        return new int[]{this.length + this.startLocation[0], this.startLocation[1]};
    }
}
